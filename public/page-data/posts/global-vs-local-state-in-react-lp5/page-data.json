{"componentChunkName":"component---src-templates-dev-article-page-js","path":"/posts/global-vs-local-state-in-react-lp5","result":{"data":{"devArticles":{"article":{"title":"Global vs Local State in React","body_markdown":"The **state** and **state management** is seemingly the most **common** and **interesting** topic when it comes to app development on the **front-end**. Thus everyone is chasing the most efficient and prominent way to manage their application state... **are we?**\n\nI'm not a guru of the state management world, however; I want to familiarize you with some basic concepts with examples, which are:\n\n- **State**\n- **Global state**\n- **Local state** _(Better put everything in the store ðŸ˜Ž)_\n\nAnd further, I'll say:\n\n- **When to use global and local state?**\n- **Popular misconceptions about state management**\n\n## The State\n\nWhy we need the state at all? The state is the **current data** that our app **stores** to control its behavior. For example, the _checkbox_ stores data (boolean) if it's **on** or **off**.\n\n## Global State\n\nGlobal means our state is accessible by **every** element/component of the app. But the important fact is that it **pollutes** the whole app since it echoes in every component that accesses it\n\n### Release the beast!\n\nTo illustrate the problem lets create a simple counter with _React_ and _Redux_:\n\n```jsx\nimport React from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { inc } from './actions'\n\nexport const Counter = () => {\n  const dispatch = useDispatch()\n  const count = useSelector(store => store.counter.count)\n\n  return (\n    <>\n      <h1>The count is: {count}</h1>\n      <button onClick={() => dispatch(inc())}>Increment</button>\n    </>\n  )\n}\n```\n\nWhat if I'll do something like this somewhere in the app:\n\n```jsx\n<>\n  <Counter />\n  <Counter />\n</>\n```\n\nYou're right. Both counters are showing up the same count:\n\n![counters animation](https://dev-to-uploads.s3.amazonaws.com/i/mw3ch8l1luhy0zairjff.gif)\n\nWith `useSelector` hook we are accessing some data stored in the global store previously declared in our app. So the **store** probably looks like this:\n\n```js\n{\n  counter: {\n    count: 0\n  }\n}\n```\n\nIt is clear that both counters display the same number cause they reflect the same state\n\n### The wind of change\n\nTo store multiple counts in the global store. We'll need to do something like this:\n\n\nChange the structure of the store:\n\n```js\n{\n  counters: [{ count: 0 }, { count: 0 }]\n}\n```\n\nChange the `Counter`:\n\n```jsx\nexport const Counter = ({ part = 0 }) => {\n  const dispatch = useDispatch()\n  // Now it selects just one of counters\n  const count = useSelector(store => store.counters[part].count)\n\n  return (\n    <>\n      <h1>The count is: {count}</h1>\n      {/*We'll also need to change our action factory and reducer */}\n      <button onClick={() => dispatch(inc(part))}>Increment</button>\n    </>\n  )\n}\n```\n\nAnd finally:\n\n```jsx\n<>\n  <Counter />\n  <Counter part={1} />\n</>\n```\n\n**Nailed it!** Just change **store**, **reducer**, **component**, and manually pass the `part` property to `Counter`...\nWhat can go wrong?\n\n### Choose your weapon _wisely_\n\nI am a big fan of _MobX_. The _MobX_ team did a great job **bending** JavaScript to allow you to **feel** _reactive_ in it:\n\n```jsx\nimport React from 'react'\nimport { observable } from 'mobx'\nimport { observer } from 'mobx-react'\n\nconst counter = observable({ count: 0 })\n\nconst Counter = observer(() => (\n  <>\n    <h1>The count is: {counter.count}</h1>\n    <button onClick={() => counter.count++}>increment</button>\n  </>\n))\n```\n\nWow, it looks so neat!\nAnd with multiple counters:\n\n```jsx\nconst counter = observable({ count: 0 })\nconst counter2 = observable({ count: 0 })\n\n// counter is now a prop:\nconst Counter = observer(({ counter }) => (\n  <>\n    <h1>The count is: {counter.count}</h1>\n    <button onClick={() => counter.count++}>increment</button>\n  </>\n))\n```\n\nNext:\n\n```jsx\n<>\n  <Counter counter={counter} />\n  <Counter counter={counter2} />\n</>\n```\nWe end up with less code, but still, we have to pass state manually for each of component ðŸ¤¦â€â™€ï¸\n## The local state\n\nEven if the above examples seem stupid, the problem is real and it shows why we need a **local state**. **Local state** is not the state we **define** locally. It has the goal to **encapsulate** the dataflow within the component:\n\n```jsx\nconst Counter = () => {\n  const [count, setCount] = useState(0)\n  const incrememt = () => setCount(count => count + 1)\n\n  return (\n    <>\n      <h1>The count is: {count}</h1>\n      <button onClick={increment}>increment</button>\n    </>\n  )\n}\n```\n\nAnd voila! counters do not share the state anymore!\n\n```jsx\n<>\n  <Counter />\n  <Counter />\n</>\n```\n\n### The dark nature of the local state\n\nSadly; the local state seems to be much **less** **manageable** and **debuggable**. What's more, it can also hurt the **performance** of _React_ app if not managed well. When you pass state many levels down and change state somewhere on the top component, **all** of its children get rerendered (inside virtual DOM) with it. It also **tangles** components together and makes them **less** **scalable**. _Redux_ **isolates** state from components **lifecycle** and **I/O**. On the other hand, **stateful** components seem to be more modular - **statefulness paradox**? No. If your app gets more **complex** things start to be more connected and it's harder to separate them, whenever it comes to global or local state\n\n## Local vs global state\n\nThe **question** you should ask yourself to keep state local or global is not to **share** or not, it's about to **encapsulate** or not\n\n## Which solution to choose\n\nWell established managers like _Redux_ and _MobX_ that supports tools like _time-travel_ (see [`mobx-state-tree`](https://mobx-state-tree.js.org/)) make debugging a pleasure. But it comes with a cost - _Redux_ is known for being **verbose** and you have to keep **discipline** when working with it. It's meant to be used in **huge** projects. If you insist to use _Redux_ in your tiny app. Take a glance at [`redux-toolkit`](https://redux-toolkit.js.org/) - an official tool to reduce _Redux_ boilerplate or search for the other _Redux_ wrapper. [_Immer_](https://immerjs.github.io/immer) is a wonderful library to write reducers. I like [_Hookstate_](https://hookstate.js.org/) - a straightforward way to lift the state up. [_Effector_](https://effector.now.sh/) is worth checking and there are plenty of libraries waiting for you to discover them\n\n### Don't follow the example\n\nWhat I'm trying to say is you shoudn't write your code to look **exactly** like examples in the web. If they want to show how things work they probably sacrifice some good things to be more specific. Reach for _Redux_ `Counter` from this article and write some custom hook:\n\n```jsx\nconst useCounter = (part = 0) => {\n  const dispatch = useDispatch()\n  const count = useSelector(store => store.counters[part].count)\n  const increment = () => dispatch({ type: 'increment' })\n  return [count, increment]\n}\n```\n\nAnd our `Counter` becomes:\n\n```jsx\nexport const Counter = ({ part = 0 }) => {\n  const [count, increment] = useCounter(part)\n  return (\n    <>\n      <h1>The count is: {count}</h1>\n      <button onClick={increment}>Increment</button>\n    </>\n  )\n}\n```\n\nThis way we moved most of the state logic outside the component. _Hooks_ are like **functions** for components. So **split** your component into **hooks** and **compose** them ass (I hope) you do with your functions\n\n## Popular misconceptions\n\n- _Redux_ is a bad tool because it's too verbose\n\nRedux is crude - that is correct. It is not designed to seduce you with code examples, but to provide transparent data flow\n\n- _Context API_ can replace Redux (or any other state manager)\n\n_Context API_ is not a state manager itself. Actually, you have to do all the management yourself like a pagan if you'll use it for that purpose. As if that were not enough, unlike several state managers, it does not optimize re-rendering. Instead, it can easily lead to unnecessary re-renders. Reach for [this](https://blog.logrocket.com/pitfalls-of-overusing-react-context/) great article\n\n- You can avoid re-renders caused by _Context API_ if you **destructure** the context value\n\n**_No!_** Please, before even thinking of doing that. Read [this](https://blog.isquaredsoftware.com/2020/01/blogged-answers-react-redux-and-context-behavior) post written by the _Redux_ maintainer @markerikson\n\n- _Context API is made for passing _state_ down (or lifting up)\n\nThe truth is: _Context API_ is just a **prop passing** solution. I think the source of this popular misconception is that a variety of libraries use _context_ for **similar** purposes, for example: passing theme state. But the theme is something that changes **occasionally**, and theme change typically **should** rerender the whole app\n\n- _MobX_ users practice voodoo\n\nðŸ™Š\n\n## Conclusion\n\nI have to confess that this section is troublesome. Should I address some advice? I've read a lot of articles touching this matter and I feel like it's so much to say - it's a complex problem to solve. So I'll just ask: what do you think about the current state of state management in _React_? and what is your current solution to deal with this problem?","url":"https://dev.to/fkrasnowski/global-vs-local-state-in-react-lp5","cover_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--LwQAbVnz--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/35qzft4k3n3o8yivmurv.png"}}},"pageContext":{"id":435599}}}