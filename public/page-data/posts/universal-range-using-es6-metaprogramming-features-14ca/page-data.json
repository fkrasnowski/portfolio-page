{"componentChunkName":"component---src-templates-dev-article-page-js","path":"/posts/universal-range-using-es6-metaprogramming-features-14ca","result":{"data":{"devArticles":{"article":{"title":"Range in JavaScript using es6 metaprogramming features","body_markdown":"Ranges and range like constructs are common features in programming languages. Such as _Python_:\n\n```py\nfor x in range(1, 4):\n  print(x)\n  #prints: 1, 2, 3\n```\n\nOr _Scala_:\n\n```scala\n(1 to 4).foreach { print } //prints: 1234\n```\n\nEven _Kotlin_:\n\n```kotlin\nfor (i in 1..4) print(i) //prints: 1234\n```\n\nNot to mention functional languages\n\n_JavaScript_ doesn't have an elegant native one range solution, neither for creating `arrays` nor for `iteration` only purposes, however; We'll try to cover those issues up and get close to perfection by using `es6` `Symbol` and `Proxy`\n\n## What do you desire?\n\nThere are a few things I want to catch up:\n\n- Creating `array` from `range`\n- Iterating through `range` efficiently\n- Checking if the `number` is in the given `range`\n- Checking if `array` from `range` includes a specifying `number`\n- Do it all in both ways:\n  - Using methods like `.forEach`\n  - Using `for(...)` loops and `in` operator\n\n## The easy peasy\n\nLet's create a skeleton for `range` function:\n\n```js\nconst range = (start, end, step = 1) => {}\n```\n\nOur `range` should have a few methods: `.forEach`, `.map`, `.includes` and `.has`\n\n> The difference between `.includes` and `.has` is that `range(1, 5).has(3)` will check if _3_ is beteen _1_ and _5_, and `(1, 5).includes(3)` will check if array from given range, which is `[1, 2, 3, 4, 5]` includes _3_ similar to `Array.proptotype.includes`\n\n```js\nconst range = (start, end, step = 1) => {\n  // Helper functions:\n  const forLoop = fn => {\n    for (let x = start; x <= end; x += step) fn(x)\n  }\n  const between = (v, start, end) => v >= start && v <= end\n  const hasValue = v => between(v, start, end) || between(v, end, start)\n  // Functions we want to expose:\n  const forEach = forLoop\n  const includes = v => {\n    for (let x = start; x <= end; x += step) {\n      if (v === x) return true\n    }\n    return false\n  }\n  const has = hasValue\n}\n```\n\nSomething is missing...\n\nYeah it's a `map` function. First create `iterate` generator:\n\n```js\nconst iterate = function* (mapFn) {\n  for (let x = start; x <= end; x += step) yield mapFn ? mapFn(x) : x\n}\n```\n\nThen use spread operator to put it outputs into array:\n\n```js\nconst map = mapFn => [...iterate(mapFn)]\n```\n\n### Create a factory\n\nAdding props with `Object.defineProperies` seems to be aproriate way:\n\n```js\nconst rangeObj = {}\n\nObject.defineProperties(rangeObj, {\n  map,\n  forEach,\n  includes,\n  has,\n})\n```\n\nWe should also wrap our methods with `{ value: method }` object to make it work:\n\n```js\n// The wrapper function\nconst createProp = v => ({ value: v })\n// Wrap all the methods\nconst map = createProp(mapFn => [...iterate(mapFn)])\nconst forEach = createProp(forLoop)\nconst includes = createProp(v => {\n  for (let x = start; x <= end; x += step) {\n    if (v === x) return true\n  }\n  return false\n})\nconst has = createProp(hasValue)\n```\n\nAll the code together:\n\n```js\nconst range = (start, end, step = 1) => {\n  const forLoop = fn => {\n    for (let x = start; x <= end; x += step) fn(x)\n  }\n\n  const between = (v, start, end) => v >= start && v <= end\n  const hasValue = v => between(v, start, end) || between(v, end, start)\n\n  const iterate = function* (mapFn) {\n    for (let x = start; x <= end; x += step) yield mapFn ? mapFn(x) : x\n  }\n\n  const rangeObj = {}\n\n  const createProp = v => ({ value: v })\n  const map = createProp(mapFn => [...iterate(mapFn)])\n  const forEach = createProp(forLoop)\n  const includes = createProp(v => {\n    for (let x = start; x <= end; x += step) {\n      if (v === x) return true\n    }\n    return false\n  })\n  const has = createProp(hasValue)\n\n  Object.defineProperties(rangeObj, {\n    map,\n    forEach,\n    includes,\n    has,\n  })\n  return rangeObj\n}\n```\n\nAdmire the result:\n\n```js\nrange(1, 2).forEach(console.log) // Logs: 1, 2\nrange(2, 5, 2).map(v => v * 10) // Outputs: [20, 40]\n...\n```\n\n## The meta part\n\n### for .. range\n\nThat's easy to accomplish. We can attach a custom iterator function to our objects, by utilizing one of the _es6_ features - `Symbols`. There are pretty interesting, but we will focus on one of the built-in `Symbols` - `Symbol.iterator`. When we set the `Symbol.iterator` we are replacing its behavior while calling `for` loops and `spread` operator:\n\n```js\nrangeObj[Symbol.iterator] = iterate\n```\n\nThis simple one-liner captures the point. Now if you call our range in `for .. of` loop, the `iterate` generator will be executed:\n\n```js\nfor (let x of range(5, 7)) console.log(x) // Logs: 5, 6, 7\n```\n\nAnd with `spread` we can simply create an `array` from the given range:\n\n```js\n;[...range(10, 30, 10)] // Outputs: [10, 20, 30]\n```\n\n### `in` operator\n\nTo check if the value is in the given range with `in` operator. Wa cannot use `Symbol` no more. `ES6` introduces another tool - `Proxy`. `Proxy` is used to trap calls like `set` and `get` to the supplied object. This way you can also trap `hasProp` which corresponds to `in` operator calls. That's how it looks like:\n\n```js\nconst rangeProxy = new Proxy(rangeObj, {\n  has(t, p) {\n    return hasValue(parseFloat(p.toString(), 10))\n  },\n})\n```\n\nThe `t` is a `target` - our `rangeObj` and the `p` is a `Symbol` with the value we want to verify if it's in range. To get the `number` value of `Symbol` we need to first call it's `.toString` method and then parse it with `parseFloat`. The output of the `has` function is the output of `in` expression:\n\n```js\n3.8 in range(1, 3) // Outputs: false\n```\n\n### A tiny problem\n\nAfter implementing `Proxy` you should mark, that when you try to `iterate` over range it stuck on an `Error`:\n\n```js\n;[...range(2, 5, 2)]\n/// TypeError: Invalid attempt to spread non-iterable instance\n```\n\nThat's because when we call spread operator it terminates if the object has its iterator and since:\n\n```js\nSymbol.iterator in range(1, 3) // Outputs: false\n```\n\nIt assumes the object is `non-iterable`\nTo fix this, just type:\n\n```js\nconst rangeProxy = new Proxy(rangeObj, {\n  has(t, p) {\n    if (p === Symbol.iterator) return true // add this line\n    return hasValue(parseFloat(p.toString(), 10))\n  },\n})\n```\n\nAnd that's it, we made it. What's left is to give it finishing touch, like making decreasing `range` - which I previously omitted for sake of simplicity:\n\n```js\nconst range = (start, end, step = 1) => {\n  if (step <= 0) throw RangeError('Step property must be positive')\n  if (start > end) step = -step\n\n  const forLoop = fn => {\n    if (step > 0) for (let x = start; x <= end; x += step) fn(x)\n    else for (let x = start; x >= end; x += step) fn(x)\n  }\n\n  const between = (v, start, end) => v >= start && v <= end\n  const hasValue = v => between(v, start, end) || between(v, end, start)\n\n  const iterate = function* (mapFn) {\n    if (step > 0)\n      for (let x = start; x <= end; x += step) yield mapFn ? mapFn(x) : x\n    else for (let x = start; x >= end; x += step) yield mapFn ? mapFn(x) : x\n  }\n\n  const rangeObj = {}\n\n  const createProp = v => ({ value: v })\n  const map = createProp(mapFn => [...iterate(mapFn)])\n  const forEach = createProp(forLoop)\n  const includes = createProp(v => {\n    for (let x = start; x <= end; x += step) {\n      if (v === x) return true\n    }\n    return false\n  })\n  const has = createProp(hasValue)\n\n  Object.defineProperties(rangeObj, {\n    map,\n    forEach,\n    includes,\n    has,\n  })\n\n  rangeObj[Symbol.iterator] = iterate\n\n  const rangeProxy = new Proxy(rangeObj, {\n    has(t, p) {\n      if (p === Symbol.iterator) return true\n      return hasValue(parseFloat(p.toString(), 10))\n    },\n  })\n\n  return rangeProxy\n}\n```\n## Caveats\n\nYou should know that `es6` `Proxy` and `Symbol` aren't poly-filled with tools like _Babel_, although `Proxy::has` is covered by [93.12%](https://caniuse.com/#feat=mdn-javascript_builtins_proxy_handler_has) browsers (by usage) and `Symbol.iterator` with [93.38%](https://caniuse.com/#feat=mdn-javascript_builtins_symbol_iterator). The `range` is a simple example of how powerful and flexible your next library can be","url":"https://dev.to/fkrasnowski/universal-range-using-es6-metaprogramming-features-14ca","cover_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--OSiLLkSM--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/l8nj7emsl98qpy2k4uo2.png"}}},"pageContext":{"id":424229}}}