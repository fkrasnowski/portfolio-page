{"componentChunkName":"component---src-templates-github-readme-page-js","path":"/projects/stateverse","result":{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"# stateverse 👽\n\nAsync state manager - painless manager for async state changes and side effects\n\n## Installation\n\n```sh\n# npm\nnpm i --save stateverse\n\n# yarn\nyarn add stateverse\n```\n\n## Features\n\n- 👣 Minimalistic API\n- 👨‍👩‍👧‍👦 Framework agnostic\n- 🦾 TypeScript support\n\n## Example\n\n```js\nconst counter = createStore(0)\n  .addReducers({\n    add: (state, v) => state + v,\n    sub: (state, v) => state - v,\n    reset: () => 0,\n  })\n  .addEffects({\n    countDownFx: async (reducers, cleanup) => {\n      const interval = setInterval(() => {\n        if (counter.state > 0) reducers.inc();\n        else clearInterval(interval);\n      }, 1000);\n      cleanup(() => {\n        clearInterval(interval);\n      });\n    },\n  });\n\ncounter.watch((count) => console.log(`counter: ${count}`));\n\ncounter.actions.add.watch((v) => console.log(`add: ${v}`));\n\ncounter.actions.sub.watch((v) => console.log(`substract: ${v}`));\n\ncounter.actions.add(10);\n//add: 10\n//counter: 10\ncounter.actions.sub(5);\n// substract: 5\n// counter: 5\ncounter.actions.countDownFx();\n// substract: 1\n// counter: 4\n// substract: 1\n// counter: 3\n//...\n```\n\n## Core concepts\n\n### Store\n\nIt's an object that holds state. You can define many stores. To define one use `createStore` factory:\n\n```js\nimport { createStore } from 'stateverse';\n\nconst store = createStore({ state });\n```\n\n### Action\n\n**Action** is either `reducer` or `effect`. Actions represent an intention to change `state`. `actions` can be attached to the store. Call action from actions property of store:\n\n```js\nstore.actions.addData({ login: 'fkrasnowski', password: '☜(ﾟヮﾟ☜)' });\n```\n\n### Reducer\n\n**Reducer** is a function that takes state (and additional values) and returns a new state that replaces the old one. Reducers must be `pure`. To define reducers use `.addReducers` method:\n\n```js\nstore.addReducers({\n  addData: (state, data) => ({ ...state, data }),\n});\n```\n\n### Effect\n\n**Effect** is a container for asynchronous state changes. `Effect` has access to all `reducers` of the `store`. Store runs one effect at the same time. If another `action` is triggered before effect finish, the effect is being canceled and the cleanup function is executed. To define effect use `.addEffects` method:\n\n```js\nstore.addEffects({\n  loadDataFx: async (reducers, cleanup, id) => {\n    reducers.setLoading(true);\n    const data = await fetchData(id);\n    reducers.addData(data);\n    reducers.setLoading(false);\n  },\n});\n```\n\n### Cleanup\n\nSome `effects` of course demand `cleanup`. To add so provide your `cleanup` function as an argument for `cleanup`. The `cleanup` function is attached asynchronously so implement it as early as possible:\n\n```js\nconst countDownFx = async (reducers, cleanup) => {\n      const interval = setInterval(() => {\n        if (counter.state > 0) reducers.inc();\n        else clearInterval(interval);\n      }, 1000);\n      cleanup(() => {\n        clearInterval(interval);\n      });\n    },\n\n```\n\n### Watchable\n\n**Watchable** is a function that can be watched. It means you can attach a `callback` to be triggered while function is called. `Actions` are watchable by default. You can create a `watchable` from function like so:\n\n```js\nimport { watchable } from 'stateverse';\n\nconst watchableFn = watchable((v) => v + 👀);\n  watchableFn.watch((...args) => console.log('watchout!',...args)));\n  watchableFn('💥') //Logs: wachout! 💥\n```\n\n### Inner state ⚠\n\nIt's really **important** to understand this idea. **Stateverse** assumes that `effects` break the integrity of the state in general. That's why effects are _`auto-canceled`_ while new `action` is being invoked. The new `action` does not operate on `state` from within canceled effect. It takes the `state` from **before** the effect has affected it! This is the so-called **inner state** - an unexposed state accessible **only** by reducers that are protected from inconstant changes\n\n## API\n\n#### `createStore<T>(initialState: T): stateverse.Store<T>`\n\nReturns store that holds state of type `T`\n\n#### `.state`\n\nReturns current state\n\n#### `.watch(callback: (state: T) => any)`\n\nAttaches a `callback` function to observe state changes\n\n#### `.unwatch(callback: (state: T) => any)`\n\nDetaches a callback function from observation\n\n```js\nconst callbackFn = fn.spy();\nstore.watch(callbackFn); //Attaches: callbackFn\n//...\nstore.unwatch(callbackFn); //Detaches: callbackFn\n```\n\n#### `.actions.<action-name>.watch(callback: (...values: any) => any)`\n\nTriggers `callback` on action call with `values` (arguments) provided to the action\n\n#### `.map<T, S>(mapFn: (state: T) => S): stateverse.WatchStore<T, S>`\n\nA map function to map state and watch only for particular state changes\n\n```js\narrayStore.map((state) => state[0]).watch(console.log);\n```\n\n#### `Reducer<T> = (state: T, ...values: any) => T`\n\nA pure function that takes state as first argument and additional values provided on action call\n\n#### `Effect = (reducers: Actions, cleanup: (cleanupFn: Cleanup) => void, ...values: any) => Promise<void>`\n\nA function returning `Promise` (`async function`)\n\n#### `.addReducers(reducers: Reducers<T>)`\n\nAdds `reducers` to store\n\n#### `.addEffects(effects: Effects)`\n\nAdds `effects` to store\n\n#### `watchable(fn: Function): watchableFn`\n\nCreates function with additional methods `.watch` and `.unwatch`\n\n## Complementary packages\n\n- **React:** [stateverse-react](https://github.com/fkrasnowski/stateverse-react)\n","repository":{"name":"stateverse","description":"Async state manager - painless manager for async state changes and side effects","url":"https://github.com/fkrasnowski/stateverse"}}}}},"pageContext":{"name":"stateverse"}}}